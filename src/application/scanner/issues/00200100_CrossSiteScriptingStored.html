<!doctype html>
<html>
<body>
<h1>Issue name</h1>
Cross-site scripting (stored)
<h1>Typical severity</h1>

High

<h1>Issue description</h1>

<p>Stored cross-site scripting vulnerabilities arise when user input is stored and later embedded into the application's responses in an unsafe way. An attacker can use the vulnerability to inject malicious JavaScript code into the application, which will execute within the browser of any user who views the relevant application content.</p>
<p>The attacker-supplied code can perform a wide variety of actions, such as stealing victims' session tokens or login credentials, performing arbitrary actions on their behalf, and logging their keystrokes.</p>
<p>Methods for introducing malicious content include any function where request parameters or headers are processed and stored by the application, and any out-of-band channel whereby data can be introduced into the application's processing space (for example, email messages sent over SMTP that are ultimately rendered within a web mail application).</p>
<p>Stored cross-site scripting flaws are typically more serious than reflected vulnerabilities because they do not require a separate delivery mechanism in order to reach target users, and are not hindered by web browsers' XSS filters. Depending on the affected page, ordinary users may be exploited during normal use of the application. In some situations this can be used to create web application worms that spread exponentially and ultimately exploit all active users.</p>
<p>Note that automated detection of stored cross-site scripting vulnerabilities cannot reliably determine whether attacks that are persisted within the application can be accessed by any other user, only by authenticated users, or only by the attacker themselves. You should review the functionality in which the vulnerability appears to determine whether the application's behavior can feasibly be used to compromise other application users. </p>

<h1>Issue remediation</h1>

<p>In most situations where user-controllable data is copied into application responses, cross-site scripting 
  attacks can be prevented using two layers of defenses:</p>
<ul>
  <li>Input should be validated as strictly as possible on arrival, given the kind of content that 
it is expected to contain. For example, personal names should consist of alphabetical 
and a small range of typographical characters, and be relatively short; a year of birth 
should consist of exactly four numerals; email addresses should match a well-defined 
regular expression. Input which fails the validation should be rejected, not sanitized.</li>
<li>User input should be HTML-encoded at any point where it is copied into 
application responses. All HTML metacharacters, including &lt; &gt; " ' and =, should be 
replaced with the corresponding HTML entities (&amp;lt; &amp;gt; etc).</li></ul>
<p>In cases where the application's functionality allows users to author content using 
  a restricted subset of HTML tags and attributes (for example, blog comments which 
  allow limited formatting and linking), it is necessary to parse the supplied HTML to 
  validate that it does not use any dangerous syntax; this is a non-trivial task.</p>
<h1>References</h1>

<ul><li><a href="https://support.portswigger.net/customer/portal/articles/1965737-Methodology_XSS.html">Using Burp to Find XSS issues</a></li></ul>

</body>
</html>
